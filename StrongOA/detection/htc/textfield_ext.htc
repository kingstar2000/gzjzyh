<!-- 
Discription: 
	This file defines the "textfield" HTC(HTML Component) and it is a part of work of Web Interactive Group, CTAIS.
Copyright & Author:
	The Digital China Corp. reserves all rights of this archive, and it is coded by Zhang Fan, zhangfanb@digitalchina.com
History:
	First this HTC is a component parsed asynchronously by the interpreter engine, but we find out some bug caused by this mechanism later. So we develop this synchronous version under the Zhang Guoxi's supervision.
	1.2002-11-04 revised by Zhang Fan.
	2.2003-08-01 revised some errors regarding the float number round by Zhang Fan.
Notes:
	我现在发现一个防止在javascript下防止浮点型数据误差的好方法,那就是对于一个数据先将其转化成为字符串,然后再利用
	parseFloat或者其他转化函数,得到的值目前来看比较精确.
-->
<!--
Attribute:
	preset, 
		can be set value each below:
		INT_NUMBER, indicate the type of the textfield htc is the purely integeral number. In this case, value only contain numbers whthin 0-9(e.g 1333) and this type is used to denote value of ID card or post number.
		NUMBER(x,y), 	indicate the type of textfield htc is the 				number and x,y are respectively the digit 				of the number's integer and decimalIndex 				fraction.(e.g 2,000,123.023,22)
		CURRENCY,		indicate the type of textfield htc is the 				currency.(e.g $2,233.939.33)
		PERCENT,		indicate the type of textfield htc is the 				pcercent.(e.g 33.22%)
		DATE,			indicate the type of textfield htc is the 				date.(e.g 2002-07-15)
		NOQUOT,			indicate the type of textfield htc is the 				normal text but without quot.(e.g 2002-07-15)
	
	fill:yes/no 控制背景颜色及是否允许空
	
	f9:
-->
<PUBLIC:COMPONENT tagName=input >
<PUBLIC:DEFAULTS viewLinkContent tabStop="true" viewMasterTab=false />
<PROPERTY NAME="preset"  />
<PROPERTY NAME="fill" put="setFill" get="getFill" />
<PROPERTY NAME="f9" />
<PROPERTY NAME="customized" />
<PROPERTY NAME="maxLength" put="setLength" get="getLength" />
<PROPERTY NAME="readOnly" put="setWritable" get="getWritable" />
<PROPERTY NAME="disable" put="setDisable" get="getDisable" />
<PROPERTY NAME="tooltip" put='setTooltip' get='getTooltip' />
<!-- <PROPERTY NAME="wrappedValue" put="setValue" get="getValue" /> -->

<METHOD NAME="getValue" />
<METHOD NAME="setValue" />
<METHOD NAME="checkData" /><!-- in fact this file does not contain this legacy method. -->
<METHOD NAME="getMessage">
<METHOD NAME="disable">
<METHOD NAME="formatData" />
<METHOD NAME="unformatData" />

<ATTACH   EVENT="oncontentready"  HANDLER="init" />
<ATTACH   EVENT="onfocus" HANDLER="onFocus" />
<ATTACH   EVENT="onblur" HANDLER="onBlur" />

<PUBLIC:EVENT NAME="onchange" ID="eChanged" />

<script language="javascript">
var bFill = false;
//Define all constant variables which determine the type of textfield
var TYPE_DEFAULT = -1;
var TYPE_PURE_NUMBER = 0;
var TYPE_NUMBER = 1;
var TYPE_CURRENCY = 2;
var TYPE_PERCENT = 3;
var TYPE_DATE = 4;
var TYPE_NOQUOT = 5;
/**
/////////////////////fieldProperties//////////////////////
//this variable is used for save the following textfield's values:
	1.fieldProperties[0] : 
		indicate the textfield's type, and can get or set through getType() or setType(var fieldType);
	2.fieldProperties[1] : 
		indicate the textfield's former htcTxt.value used for detecting the change of the htcTxt.value by comparing with the current htcTxt.value of the textfield, and can be get or set repectively through getFormerValue() or setFormerValue(var val);
	3.fieldProperties[2] : 
		indicate the extra arguments when initiating, e.g, htcTxt.value 5 of number(5,2), and can be get or set through getExtraArgs(var argIndex) or setExtraArgs(var argIndex, var val);
	4.fieldProperties[3] : 
		indicate the extra arguments when initiating, e.g, htcTxt.value 2 of number(5,2), and can be get through getExtraArgs(var argIndex) or setExtraArgs(var argIndex, var val);
*/
var fieldProperties = new Array();	
var strError = "";
/************************************************************
EVENT:
	init;
		initializes the textfield htc.
	onKeyDown;
		processes some particular response when users press a key.
	onKeyUp;
		processes some particular response when users release a key.
	onChange;
		formats the htcTxt.value of the textfield htc in some specified type when users submit changes.
	onFocus;
		highlights the content of the txtfield htc when this htc gets the focus.
**************************************************************/
function init()
{
	strError = "";
	//必须写下边这行，不然不能获得焦点
	//tabIndex = 0;
	//htcTxt.tabIndex = 0;
	htcTxt.autocomplete = "on";
	htcTxt.attachEvent('onchange', onChange);
	htcTxt.attachEvent('onkeydown', onKeyDown);
	htcTxt.attachEvent('onkeyup', onKeyUp);
	/*if(fill != null && fill.toLowerCase() == "yes")
	{
		htcTxt.style.background = "#B5E3DF";
	}*/
	//get the textfield's style
	setType(getType());
	//implement relevant operations based on the field type
	switch(getType()){
	case TYPE_DEFAULT:
		setExtraArgs(0,"NoLimit");
		setExtraArgs(1,"NoLimit");
		break;
	case TYPE_PURE_NUMBER:
		htcTxt.style.imeMode = 'disabled';
		break;
	case TYPE_NUMBER:
		htcTxt.style.imeMode = 'disabled';
		if(preset.indexOf("(") != -1){
			var arg1Start = preset.indexOf("(") + 1;
			var arg1End = preset.indexOf(",");
			var arg2Start = arg1End + 1;
			var arg2End = preset.lastIndexOf(")");
			var arg1 = parseInt(preset.substring(arg1Start,arg1End));
			var arg2 = parseInt(preset.substring(arg2Start,arg2End));
			setExtraArgs(0,isNaN(arg1)?"NoLimit":arg1);
			setExtraArgs(1,isNaN(arg2)?"NoLimit":arg2);
		}
		htcTxt.style.textAlign = "right";//set the show style
		//htcTxt.value = formatNumber(htcTxt.value);//set the default htcTxt.value
		break;
	case TYPE_CURRENCY:
		htcTxt.style.imeMode = 'disabled';
		setExtraArgs(0,"NoLimit");
		setExtraArgs(1,2);
		//htcTxt.value = formatCurrency(htcTxt.value);
		htcTxt.style.textAlign = "right";//set the show style
		break;
	case TYPE_PERCENT:
		htcTxt.style.imeMode = 'disabled';
		setExtraArgs(0,"NoLimit");
		setExtraArgs(1,2);
		//htcTxt.value = formatPercent(htcTxt.value);
		htcTxt.style.textAlign = "right";//set the show style
		break;
	case TYPE_DATE:
		htcTxt.style.imeMode = 'disabled';
		maxLength = 10;
		//htcTxt.value = formatDate(htcTxt.value);
		break;
	case TYPE_NOQUOT:
		setExtraArgs(0,"NoLimit");
		setExtraArgs(1,2);
		//htcTxt.value = formatPercent(htcTxt.value);
		htcTxt.style.textAlign = "left";//set the show style
		break;
	}

	if(isValidData(htcTxt.value))
		setValue(htcTxt.value);
	setFormerValue(htcTxt.value);
	//
	
	
}
function setTooltip(tip)
{
	htcTxt.title = tip;
}

function getTooltip()
{
	return htcTxt.title;
}

function setFill(flag)
{
	bFill = flag;
	if(flag.toString().toLowerCase() == "yes" || flag.toString().toLowerCase() == "true")
	{
		htcTxt.style.background = "#B5E3DF";
	}else {
		htcTxt.style.background = "#FFFFFF";
	}
}
function getFill()
{
	return bFill;
}

function onKeyDown()
{
	//alert(event.keyCode);
	//event.cancelBubble = true;
	strError = "";
	//alert("keydown");
	//keycode transfering, transfer "Enter" to "Tab".
	if(event.keyCode == 13){//denotes "Tab" key
		//alert("enter");
		checkData();//03.09.11fengjs增加
		if(fill != null && (fill.toString().toLowerCase() == "yes" || fill.toString().toLowerCase() == "true") && htcTxt.value == ""){
			var EXCEPTION_EMPTY_VALUE = 0;
			var DISCRIPTION_EMPTY_VALUE = "该项为必填项,不能为空!";
			buildErrorDiscription("onKeyDown",EXCEPTION_EMPTY_VALUE,DISCRIPTION_EMPTY_VALUE);
			alert(getLastError());
			return;
			}
		event.keyCode = 9;
	}
	/*else if(event.keyCode == 9)
	{
		if(fill != null && fill.toLowerCase() == "yes" && htcTxt.value == ""){
			var EXCEPTION_EMPTY_VALUE = 0;
			var DISCRIPTION_EMPTY_VALUE = "该项为必填项,不能为空!";
			buildErrorDiscription("onKeyDown",EXCEPTION_EMPTY_VALUE,DISCRIPTION_EMPTY_VALUE);
			alert(getLastError());
			event.returnValue = false;
			return;
			}
	}*/
	/*else if(event.keyCode == 9){
		alert("tab");
		if(htcTxt.value == ""){
			//setValue(htcTxt.value);
			//htcTxt.fireEvent("onchange");
			event.keyCode = 9;
			}
		if(!isValidData(htcTxt.value,true,true))
			event.returnValue = false;
		else if(getFormerValue() == getValue())
			//	setValue(htcTxt.value);
			htcTxt.fireEvent("onchange");
	}*/
	else if(event.ctrlKey && (event.keyCode == 67 || event.keyCode == 86 || event.keyCode == 88)){
		//now we doesn't process this case
		return;
	}//denotes the "Ctrl + C" and "Ctrl + X" and "Ctrl + V" behaviors
	else if(event.keyCode == 120 && f9 != null)
	{
		eval(f9);
	}
	else{
		switch(getType()){
		case TYPE_PURE_NUMBER:
			if(( 
			(event.keyCode == 8) || //"backspace" of the left keyboard
			(event.keyCode == 9) ||	//"tab" of the left keyboard
			(event.keyCode == 46) || //del" of the right keyboard
			(event.keyCode >=35 && event.keyCode <=40) || // direction keys of the right key board 
			(event.keyCode>=48 && event.keyCode <=57) || //0-9 of the left keyboard		
			(event.keyCode >= 96 && event.keyCode <=105 //0-9 of the right keyboard
		  )) == false){
			//alert("Sorry, You can't input characters except 1~9 and '-' !");
			event.returnValue = false;
		}
		case TYPE_NUMBER:
		case TYPE_CURRENCY:
		case TYPE_PERCENT:
		if(( 
			(event.keyCode == 8) || //"backspace" of the left keyboard
			(event.keyCode == 9) ||	//"tab" of the left keyboard
			(event.keyCode == 46) || //del" of the right keyboard
			(event.keyCode == 109) || //"-" of the right keyboard
			(event.keyCode == 110) || //"." of the left keyboard
			(event.keyCode == 189) || //"-" of the left keyboard
			(event.keyCode == 190) || //"." of the right keyboard
			(event.keyCode >=35 && event.keyCode <=40) || // direction keys of the right key board 
			(event.keyCode>=48 && event.keyCode <=57) || //0-9 of the left keyboard		
			(event.keyCode >= 96 && event.keyCode <=105 //0-9 of the right keyboard
		  )) == false){
		//alert("Sorry, You can't input characters except 1~9 and '-' !");
		event.returnValue = false;
		}
		/*
		Exceptions that will be processed below:
		1. Don't permit two "." in one input number.
		2. Don't permit the symbol of "-" exists in anywhere unless the head of the input string. And we should change the input number's positive or negative signal when the number of "-" character in user input is above one.
		3. Don't permit the format of current input that doesn't accord with the specified style by params fieldProperties[2],fieldProperties[3].
		*/
		//1.process the 1st case
		if(event.keyCode == 110 || event.keyCode ==190){
			if(htcTxt.value.indexOf(".") != -1) event.returnValue = false;
		}
		//2.process the 2rd case
		if(event.keyCode == 109 ||event.keyCode == 189){
			if(htcTxt.value.indexOf("-") == -1){
				setFieldValue("-" + getFieldValue());
				}
			else{
				var fieldText = getFieldValue();
				setFieldValue(fieldText.substr(1,fieldText.length-1));
			}
			event.returnValue = false;
		}
		//3.process the 3th case
		//if(!isValidData(getFieldValue()))
		//	event.returnValue = false;
		
		break;
		case TYPE_DATE:
		if((
			(event.keyCode == 8) || //"backspace" of the left keyboard
			(event.keyCode == 9) ||	//"tab" of the left keyboard
			(event.keyCode == 46) || //del" of the right keyboard
			(event.keyCode == 110) || //"." of the left keyboard
			(event.keyCode == 190) || //"." of the right keyboard
			(event.keyCode == 109) || //"-" of the right keyboard
			(event.keyCode == 189) || //"-" of the left keyboard
			(event.keyCode >=35 && event.keyCode <=40) || // direction keys of the right key board 
			(event.keyCode>=48 && event.keyCode <=57) || //0-9 of the left keyboard		
			(event.keyCode >= 96 && event.keyCode <=105 //0-9 of the right keyboard
		   )) == false){
			event.returnValue = false;
		}
		/*
		Here we list some cases need to be processed below:
		1.Requires just two "-" or "." in the string.
		2.Requires just eight numbers in the input string.
		*/
		//1.handle the case 1:
		if(event.keyCode == 109 ||event.keyCode == 189){//denote the "-" key
			if(htcTxt.value.indexOf(".") != -1){
				event.returnValue = false;
			}
			else{
				if(charCounter(htcTxt.value,"-") >= 2)
					event.returnValue = false;
			}
			
		}
		if(event.keyCode == 110 || event.keyCode == 190){//denote the "." key
			if(htcTxt.value.indexOf("-") != -1){
				event.returnValue = false;
			}
			else{
				if(charCounter(htcTxt.value,".") >= 2)
					event.returnValue = false;
			}
		}
		//2.handle the case 2:
		/*if(
			(event.keyCode>=48 && event.keyCode <=57) || //0-9 of the left keyboard		
			(event.keyCode >= 96 && event.keyCode <=105) //0-9 of the right keyboard
		   ){
				
				var number = 0;
				for(var i = 0;i<htcTxt.value.length;i++)
				if(!isNaN(parseInt(htcTxt.value.charAt(i))))
					number++;
				if(number>=8)
					event.returnValue = false;
		}*/
		break;
		case TYPE_NOQUOT:
		if( event.keyCode == 222)  //"'" of the keyboard
		{
		//alert("Sorry, You can't input characters except 1~9 and '-' !");
		event.returnValue = false;
		}
		break;
		}
	}
}

function onKeyUp()
{
	strError = "";
	switch(getType()){
		case TYPE_PURE_NUMBER:
		break;
		case TYPE_NUMBER:
		break;
		case TYPE_CURRENCY:
		break;
		case TYPE_PERCENT:
		break;
		case TYPE_DATE:
		if(event.keyCode != 8 && event.keyCode != 46){//denote "backspace" and "del" keys.
			if(htcTxt.value.length == 4 || htcTxt.value.length == 7){
				if(htcTxt.value.indexOf(".") != -1){
					if(charCounter(htcTxt.value,".")<2)
						 htcTxt.value += ".";
				}
				else
					if(charCounter(htcTxt.value,"-")<2)
						 htcTxt.value += "-";
			}
		}
		break;
		case TYPE_NOQUOT:
		break;
	}
}
function onChange()
{
	strError = "";
	//alert("changing!");
	if(!isValidData(htcTxt.value)){
		if(customized == null){
			alert(getLastError());
			event.returnValue = false;
			htcTxt.select();
			return;
		}
	}
	else{
		if(customized == null){
			if(!bubbleChange()){
				event.returnValue = false;
				htcTxt.select();
				return;
			}
		}
	}
}

function bubbleChange()
{
	strError = "";
	//alert("外部onchange");
	//Note that this 'onchange' is not regarded as an DHTML event but a common custome property of this HTC!!!!!
//	if(typeof(onchange)!="undefined")
//		eval(onchange);//implement outer instructions
	var oEvent = createEventObject();
	oEvent.returnValue = true;//
	eChanged.fire(oEvent);//这样得到的事件源srcElement为ctais:input
		if(!oEvent.returnValue) return false;
	return true;
	//alert("eChanged end");
	//element.fireEvent('onchange', event);
	//if(typeof(onchange)!="undefined")
	//	eval(onchange);//这样得到的事件源srcElement为htcTxt,破坏了组件的自封闭性！！
}

function onFocus()
{
	strError = "";
	//必须写下边这行，不然不能获得焦点
	if(htcTxt.disabled == false)
	{
	    //如果是纳税人识别号，设置光标到最后一位。 zhangcw add 2003-10-21
		if (htcTxt.maxLength==20){
			var num=htcTxt.value.length;
			range=htcTxt.createTextRange(); 
			range.collapse(true); 
			range.moveStart('character',num); 
			range.select();
		} else {
		    htcTxt.select();
		}
	}
}
function onBlur()
{
/*	if(getFormerValue() != htcTxt.value){
		event.returnValue = false;
		htcTxt.fireEvent("onchange");
	}
*/	//setValue(htcTxt.value);
	if(getType() == TYPE_PERCENT && htcTxt.value.indexOf("%") == -1){
				htcTxt.value = formatData(100*unformatData(htcTxt.value));//avoid repeaty multiple the value automaticly!
			//handleOuterChange();//invoke the module processes outer change
			}
	else
		setFieldValue(formatData(unformatData(htcTxt.value)));
}
/************************************************************
METHOD:
	getType;
		gets the type of the textfield htc.
	setType;
		sets the type of the textfield htc.
	getFormerValue;
		gets the former content showed in the htc.
	setFormerValue;
		sets the former content showed in the htc.
	getExtraArgs;
		gets extra arguments of the htc.
	setExtraArgs;
		sets extra arguments of the htc.
	getFieldValue;//NOT equal getValue
		gets the content showed in the htc.
	setFieldValue;//NOT equal setValue
		sets the content showed in the htc.
	getValue;
		gets the real htcTxt.value of the htc.
	setValue;
		sets the real htcTxt.value of the htc.

	formatData;
		formats the data to the specified formatting.
	unformatData;
		makes the type of the data revert to the naked formatting.
	formatInt;
		formats the pure number to the specified formatting.
	unformatInt;
		removes all formattings from the pure number.
	formatNumber;
		formats the number to the specified formatting.
	unformatNumber;
		makes the type of the number revert to the naked formatting.
	formatCurrency;
		formats the type of the currency specified formatting.
	unformatCurrency;
		makes the type of the currency revert to the naked formatting.
	formatPercent;
		formats the type of the percent specified formatting.
	unformatPercent;
		makes the type of the percent revert to the naked formatting.
	formatDate;
		formats the type of the date specified formatting.
	unformatDate;
		makes the type of the date revert to the naked formatting.

	isValidData;
		verifies whether the data formatting r validated.
	isValidNumber;
		verifies whether the number formatting r validated.
	isValidPercent;
		verifies whether the percent formatting r validated.
	isValidCurrency;
		verifies whether the currency formatting r validated.
	isValidDate;
		verifies whether the date formatting r validated.

	buildErrorDiscription;
		provides a easier way to show the exception message dialog box.
	charCounter;
		caculate the total number of the specified character in the whole string.
	isInRange;
		verify whether a number is in the specified range.
**************************************************************/
function setLength(len)
{
	htcTxt.maxLength = parseInt(len);
}
function getLength()
{
	return htcTxt.maxLength;
}
function setWritable(bState)
{
	//if(readOnly == null)
	//	bState = false;
	htcTxt.readOnly = bState;
}
function getWritable()
{
	return htcTxt.readOnly;
}
function setDisable(bState)
{
	htcTxt.disabled = bState;
	if(bState)
		tabIndex = -1;
	else
		tabIndex = 0;
}
function getDisable()
{
	return htcTxt.disabled;
}
function disable(bState)
{
	if(typeof(bState) == "undefined")
		bState = true;
	setDisable(bState);
}
/**	
getType
	get the type of the textfield htc.
	
	Params: null.
	Return value: TYPE_DEFAULT,	indicates the type is DEFAULT.
				  TYPE_NUMBER,	indicates the type is NUMBER.
				  TYPE_CURRENCY,indicates the type is CURRENCY.
				  TYPE_PERCENT, indicates the type is PERCENT.
				  TYPE_DATE,	indicates the type is DATE.
				  TYPE_NOQUOT,	indicates the type is NOQUOT.
	Remarks: users can get the type of the htc by calling this 			 method.

*/
/**	
getType
	get the type of the textfield htc.
	
	Params: null.
	Return value: TYPE_DEFAULT,	indicates the type is DEFAULT.
				  TYPE_NUMBER,	indicates the type is NUMBER.
				  TYPE_CURRENCY,indicates the type is CURRENCY.
				  TYPE_PERCENT, indicates the type is PERCENT.
				  TYPE_DATE,	indicates the type is DATE.
				  TYPE_NOQUOT,	indicates the type is NOQUOT.
	Remarks: users can get the type of the htc by calling this 			 method.

*/
function getType()
{
	strError = "";
	if(preset == null)
		return TYPE_DEFAULT;

	if(preset.toLowerCase().indexOf("number") != -1){
		if(preset.toLowerCase().indexOf("(") != -1)
			return TYPE_NUMBER;
		else
			return TYPE_PURE_NUMBER;
	}
	if(preset.toLowerCase().indexOf("currency") != -1)
		return TYPE_CURRENCY;
	if(preset.toLowerCase().indexOf("percent") != -1)
		return TYPE_PERCENT;
	if(preset.toLowerCase().indexOf("date") != -1)
		return TYPE_DATE;
	if(preset.toLowerCase().indexOf("noquot") != -1)
		return TYPE_NOQUOT;
}
/**	
setType
	set the type of the textfield htc.
	
	Params: fieldType, 
		present the type of the htc, and its htcTxt.value can be one of TYPE_DEFAULT,TYPE_NUMBER,TYPE_CURRENCY,TYPE_PERCENT,TYPE_DATE,TYPE_NOQUOT
	Remarks: users can set the type of the htc by calling this 			 method.

*/
function setType(fieldType)
{
	strError = "";
	fieldProperties[0] = parseInt(fieldType);
}
/**	
getFormerValue
	gets the former htcTxt.value attribute of the textfield htc.
	
	Params: null, 
	Return htcTxt.value: string that represent the former content of the htc.
	Remarks: users can get the last time htcTxt.value of the htc. 
	
	Here it is a example to instruct how to use this method below:

	//if we set the htcTxt.value of the thc to "33" first,
	var currentValue = getFieldValue();
	docuemtn.write("the current htcTxt.value is " + currentValue);
	//now we change the htcTxt.value to "555"
	var formerValue = getFieldValue();
	var currentValue = getFieldValue();
	//output resutls.
	docuemtn.write("the current htcTxt.value is " + currentValue);
	document.write("the former htcTxt.value is " + formerValue);

	//Output results r listed below:
	the current htcTxt.value is 33
	the current htcTxt.value is 555
	the former htcTxt.value is 33
	
*/
function getFormerValue()
{
	strError = "";
	return fieldProperties[1];
}
/**	
setFormerValue
	sets the former htcTxt.value attribute of the textfield htc.
	
	Params: null, 
	Return htcTxt.value: string that represent the former content of the htc.
	Remarks: users can get the last time htcTxt.value of the htc. 
	
	Here it is a example to instruct how to use this method below:

	//if we set the htcTxt.value of the thc to "33" first,
	var currentValue = getFieldValue();
	docuemtn.write("the current htcTxt.value is " + currentValue);
	//now we change the htcTxt.value to "555"
	var formerValue = getFieldValue();
	var currentValue = getFieldValue();
	//output resutls.
	docuemtn.write("the current htcTxt.value is " + currentValue);
	document.write("the former htcTxt.value is " + formerValue);

	//Output results r listed below:
	the current htcTxt.value is 33
	the current htcTxt.value is 555
	the former htcTxt.value is 33
	
*/
function setFormerValue(val)
{
	strError = "";
	fieldProperties[1] = val;	
}
/**	
getExtraArgs
	get the extra params.
	
	Params: argIndex, 
	Return htcTxt.value: the extra param specified by argIndex.
	Remarks: users can get extra params by calling this method. 
	
	Here it is a example to instruct how to use this method below:

	//if the type of htc is specified to number(5,4)
	var extraArg1 = getExtraArgs(0);
	var extraArg2 = getExtraArgs(1);
	document.write("the first extra arg is" + extraArg1);
	document.write("the second extra arg is" + extraArg2);
	//Output results r listed below:
	the first extra arg is 5
	the second extra arg is 4
*/
function getExtraArgs(argIndex)
{
	strError = "";
	return fieldProperties[argIndex + 2];
}
/**	
setExtraArgs
	stores the arguments used for specifying htc's type.
	
	Params: 
		argIndex, 0-based index denotes such arguments' index
		val, htcTxt.value assigned to the argument specified by argIndex
	Return htcTxt.value: null.
	Remarks: 
	users can sotre the arguments used for specifying htc's type, and these extra arguments usually r assigned during htc's initialization process.  By calling this method to sotre such arugments, so we can callback these arguments for later use by calling the getExtraArgs method.
	
	Here it is a example to instruct how to use this method below:
	//if the htc's type is number(5,3), and we want to store the param 5 and 3, so we should use this method like below:
	setExtraArgs(0,5);//store the first extra argument
	setExtraArgs(1,3);//store the second extra argument
*/
function setExtraArgs(argIndex,val)
{
	strError = "";
	fieldProperties[argIndex + 2] = val;
}
/**	
getFieldValue
	gets the field's original content that includes possibly seperator characters(e.g "," or "-").
	
	Params: null, 
	Return htcTxt.value: content showed in the text field.
	Remarks: users can get the htcTxt.value showed in the textfield, but there is a most important point which all users should pay attention to: getFieldValue is NOT identical to getValue, the former one's return htcTxt.value is a "ORIGINAL" htcTxt.value which possibly contais some particular artificial sperators, but the latter one's return htcTxt.value is a "PURE" htcTxt.value of field.
	
	Here it is a example to instruct how to use this method below:

	//if we set htc's htcTxt.value to 12345.6789 and its type is TYPE_CURRENCY
	fieldValue = getFieldValue();
	realValue = getValue();
	docuemtn.write("the showed htcTxt.value is " + fieldValue);
	document.write("the real htcTxt.value is " + realValue);

	//Output
	the showed htcTxt.value is $12,345.6,789
	the real htcTxt.value is 12345.6789
	
*/
function getFieldValue()//NOT equal getValue
{
	strError = "";
	return htcTxt.value;
}
/**	
setFieldValue
	sets the htcTxt.value showed in the field.
	
	Params: val, htcTxt.value showed in the field.
	Return htcTxt.value: null.
	Remarks: users can call this method to set the showed htcTxt.value of the text field. As above, here users should be reminded of difference between setFieldValue and setValue. The htcTxt.value passed by setFieldValue will be showed immediately in the field without any formatting, but the one passed by setValue possibly will be formatted for meeting to the specified field type.
	
	Here it is a example to instruct how to use this method below:
	//if the field's type is TYPE_CURRENCY
	setValue(12345.6789);
	fieldValue = getFieldValue();
	realValue = getValue();
	document.write("the fieldValue is" + fieldValue);
	document.write("the realValue is" + realValue);
	setFieldValue(12345.6789);
	fieldValue = getFieldValue();
	realValue = getValue();
	document.write("the fieldValue is" + fieldValue);
	document.write("the realValue is" + realValue);
	//Output
	the fieldValue is $12,345.67
	the realValue is 12345.67
	the fieldValue is 12345.6789
	the realValue is 12345.67
	
*/
function setFieldValue(val)//NOT equal setValue
{
	strError = "";
	setFormerValue(htcTxt.value);//save the current htcTxt.value into the former htcTxt.value param
	htcTxt.value = val;
}
/**	
getValue
	gets the real htcTxt.value of the textfield htc.
	
	Params: null, 
	Return htcTxt.value: real htcTxt.value of htc.
	Remarks: users can get the real htcTxt.value of the htc by calling this method. 
	
	Here it is a example to instruct how to use this method below:

	//if the htc's type is TYPE_NUMBER(5,4)
	setFieldValue(12,222,222.00,222);
	showedValue = getFieldValue();
	realValue = getValue();
	document.write("the showedValue is" + showedValue);
	document.write("the realValue is" + realValue);
	//if the htc's type is TYPE_CURRENCY
	setFieldValue($52,555.00,678);
	showedValue = getFieldValue();
	realValue = getValue();
	document.write("the showedValue is" + showedValue);
	document.write("the realValue is" + realValue);

	//output
	the showedValue is 22,222.0,022;
	the realValue is 22222.0022
	the showedValue is $52,555.00;
	the realValue is 52555.00

*/
function getValue()
{
	strError = "";
	var result = unformatData(htcTxt.value);
	switch(getType()){
		case TYPE_PURE_NUMBER:
			return parseInt(result);
			break;
		case TYPE_NUMBER:
		case TYPE_CURRENCY:
			return parseFloat(result);
			break;
		case TYPE_PERCENT:
			if(getType() == TYPE_PERCENT && htcTxt.value.indexOf("%") == -1)
				return parseFloat(result);
			else
				return parseFloat(result)/100;
			break;
		case TYPE_DATE:
		case TYPE_NOQUOT:
		default:
			return htcTxt.value;
			break;
	}
}
/**	
setValue
	sets the real htcTxt.value of the textfield htc.
	
	Params: val, 
	Return htcTxt.value: true indicate the operation success, otherwise false.
	Remarks: users can set the htc's Truely(intrinsic) htcTxt.value by calling this method. And users doesn't worry about the formatting process of the data, so this method can provide users an easy and immediate way to format data set in textfield.
	
	Here it is a example to instruct how to use this method below:
	//suppose the htc's type is TYPE_NUMBER
	setValue(12300.1111);
	showedValue = getFieldValue();
	document.write("the showed htcTxt.value is" + showedValue);
	//output
	the showed htcTxt.value is 12,300.1,111
	
*/
function setValue(val)
{
	strError = "";
	val = val.toString();
	//////////////////////////////Notice: the following codes improve some bug in the case of the date type
	if(getType()==TYPE_DATE)
		val = val.substr(0,10);
	////////////////////////////////////////////////////////////////////////////////
	var	bResult = true;//show the default value
	if(!isValidData(val,false))
		bResult = false;
	var str;
	if(getType()==TYPE_PERCENT && val.toString().indexOf("%")==-1)
		str = formatData(100*unformatData(val));
	else
		str = formatData(unformatData(val));
	setFieldValue(str);
	return bResult;
}
function checkData()
{
	strError = "";
	return isValidData(htcTxt.value);
}
/**	
formatData
	formats the data to the specified formatting.
	
	Params: val, represent the htcTxt.value prepared to be formatted. 
	Return htcTxt.value: the htcTxt.value with the specified formatting.
	Remarks: users can format htc's htcTxt.value through calling this method. 
	
	Here it is a example to instruct how to use this method below:
	//if the field type is TYPE_NUMBER
	number = 12345678.9012
	fNumber = formatData(number);
	document.write("the foramtted number is" + fNumber);
	//if the field type is TYPE_CURRENCY
	currency = 12345678.9012
	fCurrency = formatData(currency);
	document.write("the foramtted currency is" + fcurrency);
	//if the field type is TYPE_PERCENT
	percent = 12345678.9012
	fPerncent = formatData(percent);
	document.write("the foramtted percent is" + fPerncent);
	//if the field type is TYPE_DATE
	date = 20021201
	fDate = formatData(date);
	document.write("the formatted date is" + fDate);
	
	//output results
	the formatted number is 12,345,678.9,012
	the formatted currency is ￥12,345,678.9,012
	the formatted percent is 12,345,678.9,012%
	the formatted number is 2002-12-01
*/
function formatData(val)
{
	strError = "";

	var EXCEPTION_EMPTY_VALUE = 0;
	var DISCRIPTION_EMPTY_VALUE = "该项为必填项,不能为空!";
	val = val.toString();
	if(val == ""){
		if((fill != null) && (fill.toString().toLowerCase() == "yes" || fill.toString().toLowerCase() == "true")){
			val = defaultValue(true);//set the default htcTxt.value
			buildErrorDiscription("formatData",EXCEPTION_EMPTY_VALUE,DISCRIPTION_EMPTY_VALUE);
		}
		return val;
	}
	switch(getType()){
		case TYPE_PURE_NUMBER:
			return formatInt(val);
			break;
		case TYPE_NUMBER:
			return formatNumber(val);
			break;
		case TYPE_CURRENCY:
			return formatCurrency(val);
			break;
		case TYPE_PERCENT:
			return formatPercent(val);
			break;
		case TYPE_DATE:
			return formatDate(val);
			break;
		case TYPE_NOQUOT:
			return val;
			break;
		default:
			return val;//buildErrorDiscription("formatData",EXCEPTION_LACK_PRESET,DISCRIPTION_LACK_PRESET);
	}
}
/**	
unformatData
	removes the formatting from the data.
	
	Params: val, represent the htcTxt.value prepared to be unformatted. 
	Return htcTxt.value: the htcTxt.value without any formatting.
	Remarks: users can remove the formatting wrapped on the data by calling this method. 
	
	Here it is a example to instruct how to use this method below:
	//TYPE_CURRENCY
	unformatCurrency = unformatData("$29,222.3,454");
	document.write("unformat currency is" + unformatCurrency);
	//TYPE_NUMBER
	unformatNumber = unformatData("123,55.3,666");
	document.write("unformat number is" + unformatNumber);
	//output
	unformat currency is 29222.3454
	unformat number is 12355.3666
*/
function unformatData(val)
{
	strError = "";

	var EXCEPTION_EMPTY_VALUE = 0;
	var DISCRIPTION_EMPTY_VALUE = "该项为必填项,不能为空!";
	if(val == ""){
		if(fill != null && (fill.toString().toLowerCase() == "yes" || fill.toString().toLowerCase() == "true")){
			val = defaultValue();//set the default htcTxt.value
			buildErrorDiscription("unformatData",EXCEPTION_EMPTY_VALUE,DISCRIPTION_EMPTY_VALUE);
		}
		else if(getType() != TYPE_DEFAULT && getType() != TYPE_DATE)
			val = defaultValue();
		return val;
	}

	switch(getType()){
		case TYPE_PURE_NUMBER:
			return unformatInt(val);
			break;
		case TYPE_NUMBER:
			return unformatNumber(val);
			break;
		case TYPE_CURRENCY:
			return unformatCurrency(val);
			break;
		case TYPE_PERCENT:
			return unformatPercent(val);
			break;
		case TYPE_DATE:
			return unformatDate(val);
			break;
		case TYPE_NOQUOT:
			return val;
			break;
		default:
			return val;
			break;
	}
}
/**	
formatInt
	wraps a PURE number a specified formatting.
	
	Params: val, represent the PURE number htcTxt.value prepared to be formatted. 
	Return htcTxt.value: the htcTxt.value with the specified formatting.
	Remarks: users can format the data with the type of PURE number by calling this method. In fact, users don't need know the type of the data because the formatData method can automatic detect the type of the data and then call the relevant formatting method(e.g formatNumber or formatCurrency), so users needn't call methods like this(e.g formatCurrency, formatDate and so on) immediately.
	
*/
function formatInt(val)
{
	strError = "";
	/*
	var EXCEPTION_INVALID_CHAR = 0;//m or n is a negative number
	var DISCRIPTION_INVALID_CHAR = "含有非法字符，只能输入0-9之间的数字!";
	var i =0;
	while(i<val.length){
		if(isNaN(parseInt(val.substr(i,1))))
			return buildErrorDiscription("formatInt",EXCEPTION_INVALID_CHAR,DISCRIPTION_INVALID_CHAR);
		i++;
	}
	*/
	//return parseInt(val);
	return val.toString();
}
/**	
unformatInt
	removes the formatting from the data.
	
	Params: val, represent the PURE number htcTxt.value prepared to be unformatted. 
	Return htcTxt.value: the htcTxt.value without any formatting.
	Remarks: users can remove all formattings from the PURE number represented by val. In fact, users rarely call this method explicitly because the unformatData method contains the call for it.
	
*/
function unformatInt(val)
{
	strError = "";
	if(val == "")
		val = defaultValue();//set the defalt htcTxt.value
	//return parseInt(val);
	return val;
}
/**	
formatNumber
	wraps the formatting from the data.
	
	Params: val, represent the number htcTxt.value prepared to be formatted. 
	Return htcTxt.value: the htcTxt.value with the specified formatting.
	Remarks: users can format the data with the type of number by calling this method. In fact, users don't need know the type of the data because the formatData method can automatic detect the type of the data and then call the relevant formatting method(e.g formatNumber or formatCurrency), so users needn't call methods like this(e.g formatCurrency, formatDate and so on) immediately.
	
	Here it is a example to instruct how to use this method below:
	
	formatNumber = formatNumber("12355.3666");//this directive equal 'formatData("12355.3666")'
	document.write("format number is" + formatNumber);
	//output
	format number is $12,355.3,666
*/
function formatNumber(val)
{
	strError = "";
	var m = parseInt(getExtraArgs(0));
	var n = parseInt(getExtraArgs(1));
	return formatNumberByDigit(val,m,n,TYPE_NUMBER);
}
/** 
formatNumberByDigit
	Called by the formatNumber method,

Arguments: 
		val, the htcTxt.value needing formatting. 
		m,   specifies the integeral digits of the formatted htcTxt.value.
		n,   specifies the decimal digits of the formatted htcTxt.value
Remarks: this method is the essential and core implementation and it is the instrinsic method that formats number data. This method is the key to achive the formatting funtion by its specified
parameters, for example m and n r used to specify the digit of integer and decimal portions, contain
the most important information represent the formatting request.
Example:
		//if users want set a number format named "SampleStandard" which wraps every number indicated
		by val to a formatting number. The "SampleStandard" specifies the formatting number's integer
		and decimal digit r repecitively m and n. In this case we set the type to TYPE_NUMBER, all
		steps r listed as follows:
		
		val = 12345678.2234;
		formattingVal = formatNumberByDigit(val,5,2,TYPE_NUMBER);
		document.write("The formatting htcTxt.value is" + formattingVal);
		//output
		The formatting htcTxt.value is 45,678.22
		
		Notes that the redunant single numbers in the integeral and decimal portions r deleted by the 
		parameters m and n. So we should pay attention to the truncating affect to the original htcTxt.value(val) when formatting the val variable.
*/
function formatNumberByDigit(val,m,n,type)
{
	strError = "";
/******************USER EXCEPTION MACRO********************/
	//define a list of constant user exceptions macros
	var EXCEPTION_NEGATIVE = 0;//m or n is a negative number
	var DISCRIPTION_NEGATIVE = "必须正确指定'preset(m,n)'属性中的m,n值";
	var EXCEPTION_INVALIDATE_VALUE = 1;//the val param incorporates some illegal characters
	var DISCRIPTION_INVALIDATE_VALUE = "准备格式化的参数值不正确(例如含有非法字符等)";
/**********************************************************/
	//verify the htcTxt.value of m and n
	if(parseInt(m)<0 || parseInt(n)<0)
		buildErrorDiscription("formatNumberByDigit",EXCEPTION_NEGATIVE,DISCRIPTION_NEGATIVE);
	//assure the val variable is a string
	val = val.toString();
	if(val == "")
		return defaultValue(true);
	//if the number string includes the minus, first we should delete this signal from this string to make following computation convenient.
	var ifNegative = false;
	if(val.indexOf("-") != -1){
		val = val.substr(1,val.length-1);
		ifNegative = true;
	}
	//indicate the zero-based index of decimal point
	var decimalIndex = (val.indexOf(".")==-1) ? val.length : val.indexOf(".");
	//make the format of the htcTxt.value according with the specified format
	var intPart = null;
	var decimalPart = null;
	if(isNaN(m) || decimalIndex<=m)
		intPart = val.substr(0,decimalIndex);
	else
		intPart = val.substr(decimalIndex-m,m);
	if(isNaN(n))
		decimalPart = val.substr(decimalIndex,val.length-decimalIndex);
	else{
		if((val.length-decimalIndex-1)<=n){
			if(decimalIndex < val.length)
				decimalPart = 	val.substr(decimalIndex,val.length-decimalIndex);
			else
				decimalPart = ".";
			
			//supplement the 0 to the end of the string
			var supDigit = 0;
			if(decimalIndex < val.length)
				supDigit = n -(val.length - decimalIndex - 1);
			else
				supDigit = n;
			for(var i=0;i<supDigit;i++)
				decimalPart += "0";
		}
		else{
			//要考虑 .06 在经过parseInt()处理之后变成6的情况
			decimalPart = parseInt(val.substr(decimalIndex+1,n),10);
			var lastChar = parseInt(val.charAt(decimalIndex+n+1),10);
			if(lastChar >= 5){
				//var endChar = parseInt(decimalPart.charAt(decimalPart.length-1)) + 1;
				//decimalPart = decimalPart.substr(0,decimalPart.length-1) + endChar;
				//alert(parseFloat(decimalPart));
				//alert(Math.pow(0.1,n));
				//decimalPart = (parseFloat(decimalPart)+Math.pow(0.1,n)).toString();
				decimalPart += 1;
				//如果增加1后进位了,则应该考虑整数部分增加1
				if(decimalPart.toString().length != (decimalPart-1).toString().length){
					//alert("big");
					//整数部分增加1,还要考虑之后可能超过m定义的位数限制!
					var originalInt = intPart;
					intPart = (parseInt(intPart,10) + 1).toString();
					if(originalInt.length != intPart.length)
						intPart = intPart.substr(intPart.length-originalInt.length);
					//alert(intPart);
					//小数部分重新确定
					decimalPart = parseInt(decimalPart - parseInt(Math.pow(10,n)),10).toString();
					//alert(decimalPart);
					//alert(decimalPart.length);
					if(decimalPart.length < n){
						for(var i=0;i<n-decimalPart.length;i++)
							decimalPart += "0";
					}
					//alert(decimalPart);
				}
				else{
					//要考虑 .06 在经过parseInt()处理之后变成6的情况
					decimalPart = decimalPart.toString();
					if(decimalPart.length < n){
						for(var i=0;i<n-decimalPart.length;i++)
							decimalPart = "0" + decimalPart;
					}
				}
			}
			decimalPart = "." + decimalPart.toString();
		}
	}
	if(intPart!=null && decimalPart!=null)
		val = intPart + decimalPart;

	/**important!
	calculate the htcTxt.value of the decimalIndex variable again to accord with the new htcTxt.value
	*/
	var decimalIndex = (val.indexOf(".")==-1) ? val.length : val.indexOf(".");

	var startIndex = 0; 
	var formatResult = "";
	
	while(startIndex< val.length){
		var residue = decimalIndex - 3*parseInt(decimalIndex/3);
		if(startIndex ==0 && residue !=0){
			formatResult = val.substr(startIndex,residue);
			startIndex = residue;
			}
		else{
			if(val.substr(startIndex,3).indexOf(".")==-1){
				if(startIndex == 0)
					formatResult += val.substr(startIndex,3);	
				else
					formatResult += "," + val.substr(startIndex,3);	
	
				startIndex += 3;
			}
			else{
				formatResult += val.substr(startIndex,4);
				startIndex += 4;
			}
		}
	}

	
	if(ifNegative == true){
		val = "-" + val;
		formatResult = "-" + formatResult;//important!
	}
	switch(type){
	case TYPE_PURE_NUMBER:
	case TYPE_NUMBER:
	case TYPE_CURRENCY://now this method doesn't wrap the "$" prefix on the currency htcTxt.value
	break;
	case TYPE_PERCENT:
	formatResult += "%";
	break;
	case TYPE_NOQUOT:
	}
	return formatResult;
}
/**	
unformatNumber
	removes the formatting from the data.
	
	Params: val, represent the number htcTxt.value prepared to be unformatted. 
	Return htcTxt.value: the htcTxt.value without any formatting.
	Remarks: users can remove all formattings from the number represented by val. In fact, users rarely call this method explicitly because the unformatData method contains the call for it.
	
	Here it is a example to demonstrate how to use this method below:
	//
	unformatNumber = unformatNumber("-199,111.022");
	document.write("the unformatted number is" + unformatNumber);
	//output
	the unformatted number is -199111.022
*/
function unformatNumber(val)
{
	strError = "";
	if(val == "")
		return parseFloat(defaultValue());

	var unformatResult = "";
	var i = 0;
	while(i < val.length){
		if((val.substr(i,1) == "-") || (val.substr(i,1) == ".") || !isNaN(parseInt(val.substr(i,1)))) //assure every char be a pure number
			unformatResult += val.substr(i,1);
		i++;
	}
	return parseFloat(unformatResult);
}
/**	
formatCurrency
	formats the data with the formatting of currency.
	
	Params: val, represent the data prepared to be formatted. 
	Return htcTxt.value: the currency wrapped with the currency formatting.
	Remarks: users can format data with the currency formatting by calling this method. If wantting to know more about its usage u can refer to the specification of the formatNumber method.
	
*/
function formatCurrency(val)
{
	strError = "";
	var m = getExtraArgs(0);
	var n = getExtraArgs(1);
	return formatNumberByDigit(val,m,n,TYPE_CURRENCY);
}
/**	
unformatCurrency
	removes the formatting from the data.
	
	Params: val, represent the number htcTxt.value prepared to be unformatted. 
	Return htcTxt.value: the htcTxt.value without any formatting.
	Remarks: users can remove all formattings from the number represented by val. In fact, users rarely call this method explicitly because the unformatData method contains the call for it.
	
*/
function unformatCurrency(val)
{
	strError = "";
	return unformatNumber(val);
}
/**	
formatPercent
	formats the data with the formatting of percent.
	
	Params: val, represent the data prepared to be formatted. 
	Return htcTxt.value: the htcTxt.value wrapped with the percent formatting.
	Remarks: users can format data with the percent formatting by calling this method. If wantting to know more about its usage u can refer to the specification of the formatNumber method.
	
*/
function formatPercent(val)
{
	strError = "";
	var m = getExtraArgs(0);
	var n = getExtraArgs(1);
	//note val/100!
	return formatNumberByDigit(val,m,n,TYPE_PERCENT);
}
/**	
unformatPercent
	removes the formatting from the data.
	
	Params: val, represent the number htcTxt.value prepared to be unformatted. 
	Return htcTxt.value: the htcTxt.value without any formatting.
	Remarks: users can remove all formattings from the htcTxt.value represented by val. In fact, users rarely call this method explicitly because the unformatData method contains the call for it.If wantting to know more about its usage u can refer to the specification of the unformatNumber method.
	
*/
function unformatPercent(val)
{
	strError = "";
	return unformatNumber(val);
}
/**	
formatDate
	formats the data with the formatting of date.
	
	Params: val, represent the data prepared to be unformatted. 
	Return htcTxt.value: the htcTxt.value wrapped with the date formatting.
	Remarks: users can format data with the date formatting by calling this method. If wantting to know more about its usage u can refer to the specification of the formatNumber method.
	
*/
function formatDate(val)
{
	strError = "";
	//assure the val variable is a string
	val = "" + val + "";
	//set the defaul htcTxt.value
	if(val == "")
		return defaultValue(true);

	var strResult = val;
	//verify the validity of the date
//	if(isValidDate(val)){
		var year;
		var month;
		var day;
		var strFilter;
		//verify whether the val string includes two "-" or "." sperators
		if((val.indexOf("-") == -1) && (val.indexOf(".") == -1)){
			year = val.substr(0,4);
			month = val.substr(4,2);
			day = val.substr(6,2);
			strResult = year + "-" + month + "-" + day;// format the htcTxt.value of val
		}	
		else{
			//get the corresponding htcTxt.value of the year, month and day
			var firstSepratorIndex;
			var lastSepratorIndex;
			if(val.indexOf("-") != -1){
				firstSepratorIndex = val.indexOf("-");
				lastSepratorIndex = val.lastIndexOf("-");
				}
			else{
				firstSepratorIndex = val.indexOf(".");
				lastSepratorIndex = val.lastIndexOf(".");
				}
			year = val.substring(0,firstSepratorIndex);
			month = val.substring(firstSepratorIndex+1,lastSepratorIndex);
			day = val.substring(lastSepratorIndex+1,val.length);
			if(year.length == 2){
				var tempDate = new Date();
				year = tempDate.getFullYear().toString().substr(0,2) + year;
			}
			if(month.length == 1)
				month = "0" + month;
			if(day.length == 1)
				day = "0" + day;
			strResult = year + "-" + month + "-" + day;
		}
	//}
	return strResult;
}
/**	
unformatDate
	removes the formatting from the data.
	
	Params: val, represent the number htcTxt.value prepared to be unformatted. 
	Return htcTxt.value: the htcTxt.value without any formatting.
	Remarks: users can remove all formattings from the date represented by val. In fact, users rarely call this method explicitly because the unformatData method contains the call for it.If wantting to know more about its usage u can refer to the specification of the unformatNumber method.
	
*/
function unformatDate(val)
{
	strError = "";
	return val;
}
/**	
isValidData
	judges whether the data has a valid formatting.
	
	Params: 
		val, the checked htcTxt.value
	Return htcTxt.value: 
		true denotes param val is a valid htcTxt.value, otherwise false.
	Remarks: 
		users can filter most of illegal input by calling this mehod.
	Here it is two example to instruct how to use this method below:
	//1.first suppose the type of textfield is TYPE_NUMBER
	val = 123**33./; //includes some illegal characters(e.g "*")
	valValid = 12322.0023
	result = isValidData(val);
	resultValid = isValidData(valValid);
	document.write("the val is" + result?"valid":"invalid");
	document.write("the valValid is" + resultValid?"valid":"invalid");
	//output in the case 1
	the val is invalid
	the valValid is valid
	
	//2.then suppose the type of texfield is TYPE_DATE
	val = 20080483;
	valValid = 20020101;
	result = isValidData(val);
	resultValid = isValidData(valValid);
	document.write("the val is" + result?"valid":"invalid");
	document.write("the valValid is" + result?"valid":"invalid");
	//output in the case 2
	the val is invalid
	the valValid is valid
*/
function isValidData(val,bNotice)
{
	if(isValidData.arguments.length == 0) 
		bNotice = true;
	strError = "";
	var EXCEPTION_EMPTY_VALUE = 0;//this constant indicate that the length of the val variable is not meeting to that we need
	var DISCRIPTION_EMPTY_VALUE = "此项不允许为空!";//string showed in the alert box is used to prompt the error discription
	val = val.toString();//revert val to a string
	if(val == "" && bNotice){
		if(fill !=null && (fill.toString().toLowerCase() == "yes" || fill.toString().toLowerCase() == "true")){
			buildErrorDiscription("isValidData", EXCEPTION_EMPTY_VALUE, DISCRIPTION_EMPTY_VALUE);
			return false;
		}
		return true;
	}

	var result = true;
	switch(getType()){
	case TYPE_DEFAULT:
		result = true;
		break;
	case TYPE_PURE_NUMBER:
	case TYPE_NUMBER:
		result = isValidNumber(val);
		break;
	case TYPE_CURRENCY:
		result = isValidCurrency(val);
		break;
	case TYPE_PERCENT:
		result = isValidPercent(val);
		break;
	case TYPE_DATE:
		result = isValidDate(val);
		break;
	}

	return result;
}
/**
verify whether the val variable is the number with the correct format
Arguments: val 
Remarks: 
Example:
*/
function isValidNumber(val)
{		
	strError = "";
	var i = 0;
	
		//the pure type number consist of the pure numbers(0-9) and comma.
		//NOTE that in fact there isn't "," in user's input data, the commas r inserted by program during formatting!
		strFilter = "";
		var EXCEPTION_INVALID_CHAR = 0;
		var DISCRIPTION_INVALID_CHAR = "含有非法字符!";
		while(i<val.length){
			var str = val.substr(i,1);
			if(getType() == TYPE_PURE_NUMBER){
				if(str!="," && isNaN(parseInt(str))){
					buildErrorDiscription("isValidNumber", EXCEPTION_INVALID_CHAR, DISCRIPTION_INVALID_CHAR);
					return false;
				}
			}
			else{
				if(str!="." && str!="-" &&	str!="," && isNaN(parseInt(str))){
					buildErrorDiscription("isValidNumber", EXCEPTION_INVALID_CHAR, DISCRIPTION_INVALID_CHAR);
					return false;
				}
			}
			//strFilter += (str != "," && str != "-") ? str : "";
			i++;
		}
	/*
	val = strFilter;
	var m = parseInt(getExtraArgs(0));
	var n = parseInt(getExtraArgs(1));
	var decimalIndex = val.toString().indexOf(".");
	var intCount = decimalIndex;
	var decimalCount = val.length - decimalIndex -1;
	if(!isNaN(m)){
		if(!isNaN(n)){
			if(intCount>m || decimalIndex>n)
				return false;
		}
		else{
			if(intCount>m)
				return false;
		}
	}
	else{
		if(!isNaN(n)){
			if(decimalIndex>n)
				return false;
		}
	}
	*/	
	return true;
}

function isValidCurrency(val)
{
	strError = "";
	return isValidNumber(val);
}

function isValidPercent(val)
{
	strError = "";
	var EXCEPTION_INVALID_CHAR = 0;
	var EXCEPTION_INVALID_CHAR = "不能含有多个'%'符号!";
	if(charCounter(val,"%") > 1){
		buildErrorDiscription("isValidPercent", EXCEPTION_INVALID_CHAR, DISCRIPTION_INVALID_CHAR);
		return false;
	}
	var qual = /%/g;
	var noQualifierVal = val;
	noQualifierVal = noQualifierVal.replace(qual, "");
	return isValidNumber(noQualifierVal);
}

function isValidDate(val) 
{
	strError = "";
	/**********************Exception Macro********************/
	var EXCEPTION_ILLIGAL_LENGTH = 0;//this constant indicate that the length of the val variable is not meeting to that we need
	var DISCRIPTION_ILLIGAL_LENGTH = "日期输入长度错误,日期输入格式应为yyyy-mm-dd!";//string showed in the alert box is used to prompt the error discription.
	var EXCEPTION_VALIDATION_ERROR = 1;//this constant represent that the formatting date is a wrong htcTxt.value.
	var DISCRIPTION_VALIDATION_ERROR = "时间格式输入错误,日期输入格式应为yyyy-mm-dd!";//string specifies that the meaning of this kind of exception
	var EXCEPTION_LACK_SEPERATOR = 2;//this constant represent that the formatting date is a wrong htcTxt.value.
	var DISCRIPTION_LACK_SEPERATOR = "缺少分隔符!\n您可以使用yyyy-mm-dd或者yyyy.mm.dd的分割格式。";//string specifies that the meaning of this kind of exception
	var EXCEPTION_ERROR_DATE = 3;//this constant represent that the formatting date is a wrong htcTxt.value.
	var DISCRIPTION_ERROR_DATE = "日期数值错误，年月日输入不完整!";//string specifies that the meaning of this kind of exception
	var EXCEPTION_ILLIGAL_CHAR = 4;//this constant represent that the formatting date is a wrong htcTxt.value.
	var DISCRIPTION_ILLIGAL_CHAR = "含有非法字符!";//string specifies that the meaning of this kind of exception
	var EXCEPTION_OVER_RANGE = 5;//this constant represent that the formatting date is a wrong htcTxt.value.
	var DISCRIPTION_OVER_RANGE = "取值越界!";//string specifies that the meaning of this kind of exception
	/**********************************************************/

	var DATE_LENGTH = 8;//commonly the date's format is a 8-digit string if we ignore all characters except number.
	var year;
	var month;
	var day;
	var strFilter;
	//verify whether the val string includes two "-" or "." sperators
	if((val.indexOf("-") == -1) && (val.indexOf(".") == -1)){
		//get the filter string that dosen't include seperating characters.
		strFilter = parseInt(val).toString();
		//handle the exception case and return a exception string
		if(isNaN(strFilter) || (strFilter.length != DATE_LENGTH)){
			if(strFilter.length > DATE_LENGTH)
				buildErrorDiscription("formatDate",EXCEPTION_LACK_SEPERATOR,DISCRIPTION_LACK_SEPERATOR);
			else
				buildErrorDiscription("formatDate",EXCEPTION_ILLIGAL_LENGTH,DISCRIPTION_ILLIGAL_LENGTH);
			return false;
		}
		//
		year = val.substr(0,4);
		month = val.substr(4,2);
		day = val.substr(6,2);
		val = year + "-" + month + "-" + day;// format the htcTxt.value of val
	}	
	else{
		if(val.indexOf("-") != -1){
			if(charCounter(val,"-") != 2){
			buildErrorDiscription("formatDate",EXCEPTION_LACK_SEPERATOR,DISCRIPTION_LACK_SEPERATOR);
			return false;
			}
		}
		else if(charCounter(val,".") != 2){
			buildErrorDiscription("formatDate",EXCEPTION_LACK_SEPERATOR,DISCRIPTION_LACK_SEPERATOR);
			return false;
		}

		//get the filter string that dosen't include seperating characters.
		strFilter = "";
		for(var i = 0;i< val.length;i++){
			if(!isNaN(parseInt(val.charAt(i))))
				strFilter += val.charAt(i);
		}
		//handle the exception case and return a exception string
		if(strFilter.length > DATE_LENGTH){
			buildErrorDiscription("formatDate",EXCEPTION_ILLIGAL_LENGTH,DISCRIPTION_ILLIGAL_LENGTH);
			return false;
		}

		//get the corresponding htcTxt.value of the year, month and day
		var firstSepratorIndex;
		var lastSepratorIndex;
		if(val.indexOf("-") != -1){
			firstSepratorIndex = val.indexOf("-");
			lastSepratorIndex = val.lastIndexOf("-");
			}
		else{
			firstSepratorIndex = val.indexOf(".");
			lastSepratorIndex = val.lastIndexOf(".");
			}
		year = val.substring(0,firstSepratorIndex);
		month = val.substring(firstSepratorIndex+1,lastSepratorIndex);
		day = val.substring(lastSepratorIndex+1,val.length);

		if(!(year.length == 2 || year.length == 4) || !isInRange(month.length,1,2) || !isInRange(day.length,1,2)){
			buildErrorDiscription("formatDate",EXCEPTION_ILLIGAL_LENGTH,DISCRIPTION_ILLIGAL_LENGTH);
			return false;
			}
		if(year.length == 2){
			var tempDate = new Date();
			year = tempDate.getFullYear().toString().substr(0,2) + year;
		}
		if(month.length == 1)
			month = "0" + month;
		if(day.length == 1)
			day = "0" + day;
		val = year + "-" + month + "-" + day;
	}

	//mainly detect the validation of relation that locates among the year,month and day
	var strDateArray;
	var strDay = "";
	var strMonth = "";
	var strYear = "";
	var intday;
	var intMonth;
	var intYear;
	var booFound = false;
	var datefield = val;
	var strSeparatorArray = new Array("-","."," ","/");
	var intElementNr;
	// var err = 0;
	var strMonthArray = new Array(12);
	strMonthArray[0] = "Jan";
	strMonthArray[1] = "Feb";
	strMonthArray[2] = "Mar";
	strMonthArray[3] = "Apr";
	strMonthArray[4] = "May";
	strMonthArray[5] = "Jun";
	strMonthArray[6] = "Jul";
	strMonthArray[7] = "Aug";
	strMonthArray[8] = "Sep";
	strMonthArray[9] = "Oct";
	strMonthArray[10] = "Nov";
	strMonthArray[11] = "Dec";

	if (val.length < 1) {
	return true;
	}
	for (var intElementNr = 0; intElementNr < strSeparatorArray.length; intElementNr++) {
		if (val.indexOf(strSeparatorArray[intElementNr]) != -1) {
			strDateArray = val.split(strSeparatorArray[intElementNr]);
			if (strDateArray.length != 3) {
				err = 1;
				buildErrorDiscription("isValidDate",EXCEPTION_ERROR_DATE,DISCRIPTION_ERROR_DATE);
				return false;
			}
			else {
				strDay = strDateArray[2];
				strMonth = strDateArray[1];
				strYear = strDateArray[0];
			}
			
			booFound = true;
	   }
	}

	if (booFound == false) {
		if (val.length>5) {
			strYear = val.substr(0, 2);
			strMonth = val.substr(2, 2);
			strDay = val.substr(4);
		   }
	}
	//verify whether the date lacks of some item among year, month and day.
	var EXCEPTION_LACK_ITEM = 3;//indicates whether the exception refered above occured.
	var DISCRIPTION_LACK_ITEM = "输入日期长度错误,缺少: ";
	if(strYear == "" || strMonth == "" || strDay == ""){
			//DISCRIPTION_LACK_ITEM += (strYear == "")?"年份":"" + (strMonth == "")?",月份":"," + (strDay == "")?"天数":"" + "!";
			DISCRIPTION_LACK_ITEM = "日期输入长度错误,日期输入格式应为yyyy-mm-dd!";
			buildErrorDiscription("isValidDate", EXCEPTION_LACK_ITEM, DISCRIPTION_LACK_ITEM);
			return false;
		}

	//Adjustment for short years entered
	if (strYear.length == 2) {
		var tempDate = new Date();
		strYear = tempDate.getFullYear().toString().substr(0,2) + strYear;
	}
	
	intday = parseInt(strDay, 10);
	if (isNaN(intday)) {
		err = 2;
		buildErrorDiscription("isValidDate",EXCEPTION_ILLIGAL_CHAR,"日期"+DISCRIPTION_ILLIGAL_CHAR);
		return false;
	}

	intMonth = parseInt(strMonth, 10);
	if (isNaN(intMonth)) {
		for (i = 0;i<12;i++) {
			if (strMonth.toUpperCase() == strMonthArray[i].toUpperCase()) {
				intMonth = i+1;
				strMonth = strMonthArray[i];
				i = 12;
		   }
		}
		if (isNaN(intMonth)) {
			err = 3;
			buildErrorDiscription("isValidDate",EXCEPTION_ILLIGAL_CHAR,"月份"+DISCRIPTION_ILLIGAL_CHAR);
			return false;
		}
	}

	intYear = parseInt(strYear, 10);
	if (isNaN(intYear)) {
		err = 4;
		buildErrorDiscription("isValidDate",EXCEPTION_ILLIGAL_CHAR,"年份"+DISCRIPTION_ILLIGAL_CHAR);
		return false;
	}
	if (intMonth>12 || intMonth<1) {
		err = 5;
		buildErrorDiscription("isValidDate",EXCEPTION_OVER_RANGE,"月份"+DISCRIPTION_OVER_RANGE);
		return false;
	}
	if ((intMonth == 1 || intMonth == 3 || intMonth == 5 || intMonth == 7 || intMonth == 8 || intMonth == 10 || intMonth == 12) && (intday > 31 || intday < 1)) {
		err = 6;
		buildErrorDiscription("isValidDate",EXCEPTION_OVER_RANGE,"日期"+DISCRIPTION_OVER_RANGE);
		return false;
	}
	if ((intMonth == 4 || intMonth == 6 || intMonth == 9 || intMonth == 11) && (intday > 30 || intday < 1)) {
		err = 7;
		buildErrorDiscription("isValidDate",EXCEPTION_OVER_RANGE,"日期"+DISCRIPTION_OVER_RANGE);
		return false;
	}
	if (intMonth == 2) {
		if (intday < 1) {
			err = 8;
			buildErrorDiscription("isValidDate",EXCEPTION_OVER_RANGE,"日期"+DISCRIPTION_OVER_RANGE);
			return false;
		}
		if (LeapYear(intYear) == true) {
			if (intday > 29) {
				err = 9;
				buildErrorDiscription("isValidDate",EXCEPTION_OVER_RANGE,"日期"+DISCRIPTION_OVER_RANGE);
				return false;
			}
		}
		else {
			if (intday > 28) {
				err = 10;
				buildErrorDiscription("isValidDate",EXCEPTION_OVER_RANGE,"日期"+DISCRIPTION_OVER_RANGE);
				return false;
			}
	   }
	}

	return true;

}
/**	
leapYear
	determine whether the specified year is a leap year.
	
	Params: intYear, specifies the checked year. 
	Return htcTxt.value: true indicates the intYear is a leap year and otherwise false.
	Remarks: 
*/
function LeapYear(intYear) {
	strError = "";
	if (intYear % 100 == 0) {
	if (intYear % 400 == 0) { return true; }
	}
	else {
	if ((intYear % 4) == 0) { return true; }
	}
	return false;
}
/**	
buildErrorDiscription
	shows a exception prompt dialog box.
	
	Params: 
		functionName, the name of the function call this method
		exceptionCode, the exception code
		discriptOfException, the exception's discription
	Return htcTxt.value: the exception discription string that includes the exception code and discription.
	Remarks: a easy way to show exception prompt dialog box.
	
	Here it is a example to instruct how to use this method below:
	//if a code splice in a function named exampleFunction possibly occurs a exception that its exception code is defined to EXCEPTION_NULL_POINTER and its exception discription is described to "空值针错误!". Then we call this method:
	var ex =  buildErrorDiscription("exampleFunction",EXCEPTION_NULL_POINTER,"空值针错误!");
	//then we can judge whether exceptions occur through the returnhtcTxt.value of this method
	if(ex.indexOf("UserException") != -1)
		alert("Exceptions occuring!);
*/
function buildErrorDiscription(functionName,exceptionCode,discriptOfException)
{
	strError = "操作提示: \n" + discriptOfException;// + "\n Error Code: UserException_"+ functionName + "_" + exceptionCode;
	return strError;
}

function getLastError()
{
	if(strError.indexOf("操作提示:") != -1)
		return strError;
	else
		return null;
}
function getMessage()
{
	return getLastError();
}
/**	
charCounter
	caculates how many specified characters a string contains.
	
	Params: 
		str, represents the string
		c,	specifies the character
	Return htcTxt.value: the number of the c character contained in the str.
	Remarks:
	
	Here it is a example to instruct how to use this method below:
	//
	str = "digitalchina";
	c = 'i';
	count = charCounter(str,c);
	document.write("str includes " + count + c + "characters");
	//output
	str includes 3 i characters.
*/
function charCounter(str,c)
{
	strError = "";
	var i = 0;
	var count = 0;
	while(i<str.length){
		if(str.charAt(i) == c) count++;
		i++;
	}
	return count;
}

/**	
isInRange
	judges a number is in the range of the specified range.
	
	Params: 
		val, detected htcTxt.value
		begin, the lower htcTxt.value of the range
		end, the upper htcTxt.value of the range
	Return htcTxt.value: true denotes the val in the range sppecified by param begin and end, otherwise false.
	Remarks: 
	this method is identical to the expression below,
	"if(val >= begin && val <= end)"
	
*/
function isInRange(val,begin,end)
{
	if(val >= begin && val <= end)
		return true;
	return false;
}

function defaultValue(bHasDecorator)
{
	var defaultValue;
	switch(getType()){
	//现在让number型的默认值为空
	case TYPE_PURE_NUMBER:
		//defaultValue = 0;
		defaultValue = "";
	break;
	case TYPE_NUMBER:
	case TYPE_CURRENCY://now this method doesn't wrap the "$" prefix on the currency htcTxt.value
	case TYPE_PERCENT:
		defaultValue = "0.";
		//supplement some "0" to the end of this string for meeting the specified format
		var n = getExtraArgs(1);
		for(var i=0;i<parseInt(n);i++)
			defaultValue += "0";
	break;
	case TYPE_DATE:
		//defaultValue = "0000-00-00";
		defaultValue = "";
	break;
	case TYPE_NOQUOT:
		defaultValue = "";
	break;
	default:
		defaultValue = "";
	}
	if(bHasDecorator != null && bHasDecorator)
		if(getType() == TYPE_PERCENT) defaultValue += "%";//append the qualifier to the end of the htcTxt.value

	return defaultValue;
}

</script>

</PUBLIC:COMPONENT>

<BODY>
<INPUT TYPE="TEXT" style='width:100%;font-size:12pt;color:black;
	margin-right:0;margin-top:0;margin-left:0;margin-bottom:0;
	BORDER-TOP-WIDTH: 1px;
    BORDER-LEFT-WIDTH: 1px;
    BORDER-LEFT-COLOR: #cecece;
    BORDER-BOTTOM-WIDTH: 1px;
    BORDER-BOTTOM-COLOR: #cecece;
    BORDER-TOP-COLOR: #cecece;
    BACKGROUND-COLOR: #ffffff;
    BORDER-RIGHT-WIDTH: 1px;
    BORDER-RIGHT-COLOR: #cecece'id="htcTxt">
</BODY>

